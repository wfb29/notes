#Java应用应用架构设计-模块化模式与OSGI

##1 模块定义
>软件模块是可部署的，可管理的，原生可重用的，可组合的，无状态的软件单元，为用户提供了简洁的接口。

应用------------>模块------------->包-------------->类

- 应用与模块为部署和管理单元
- 类为状态单元
- 应用为进程间重用单元
- 模块、包、类为进程内重用单元

###可部署
模块可以单独部署，包括的例子包含EAR，WAR，JAR。

###可管理
可管理单元，在系统中可以按照、卸载及更新。

###可测试
模块作为可测试的单元，可以进行独立的测试。类似于测试驱动的类。

###原生可重用
进程内使用。

###可组合

###无状态
特性模块只会存在一个实例。

>java平台中最适合模块化单元就是JAR文件。

##2 模块化的两个方面

###运行时模型
运行时模型关注如何在运行时对模块化的软件系统进行管理。需支持以下的功能。

- 封装 提供隐藏实现细节的能力
- 动态部署 支持热部署，更新软件不需要重启
- 版本管理 支持部署多个模块
- 依赖管理 实现运行时的依赖管理

###开发模型
开发模型解决的问题是开发人员怎样使用框架构建软件应用。

####编程模型
####设计范式

1. 面向对象
2. EJB

##3 架构与模块化

>一个系统的节本组织，通过组件、组件之间和组建与环境之间的关系以及管理其设计和演变的原则具体实现。

架构师不能仅仅关注服务，开发人员也不能仅仅关注代码。必须通过模块和包设计来先出高层抽象和代码之间的断层。

>所有的家头都是设计，但并不是所有的设计都是架构。架构表现为重要的设计决策，这些决策会形成系统，在这里重要性是通过变化的成本衡量的。

让每件事易于变化会使得整个系统非常复杂。 

##4 征服复杂性

软件维护以及烟花的管理成本会占到总成本的90%以上，

技术债务是指为了满足进度和用户期望而做出的设计让步。

设计腐化、循环依赖

SOLID
- Single Responsible
- Open Closed
- Liskov Substitution
- Dependency Inversion
- Interface Segregation

模块式比对象更粗粒度的单元，它允许我们封装复杂的设计决策，模块可能包含很多的类，但是类之间的关系的设计决策可以封装在模块中，内聚的模块会封装行为并通过定义良好的接口提供它。

优点：
- 可重用
- 减少复杂性
- 降低维护成本
- 将变化局限在模块内

##5 实现重用

可用性和重用性的悖论：
>最大化重用会使得可用性复杂化、

重量级值得是模块依赖其环境的程度。
轻量级模块更易重用，重量级模块更易于使用。

逻辑设计会影响可扩展性，物理设计会影响可用性和可重用性。


##二 模块架构模式

##1 基本模式

### 管理关系
输入依赖，其它模块依赖当前模块，则当前模块存在输入依赖。如果模块依赖于其它模块中的类，那么当前模块存在输出依赖。

输出依赖多的模块更容易变化，但是不容易测试。
具备大量输入依赖的模块应该是很稳定的。难以变化，进行变化时候，带来的问题是维护和部署。

### 模块重用
对象并不能帮助我们创建更加可重用的软件。事实上，对象会帮助我们创建可扩展性强的软件，这会促进可重用性。

类设计灵活--》可扩展性强--》模块可重用性。
### 模块内聚
模块的行为应该只服务于一个目的。

##2 依赖模式
用于管理模块之间的关系。

### 非循环关系
模块之间的依赖关系式非循环的。

### 等级化模块
模块关系应该是等级化的。

### 物理分层
模块关系不能违反概念上的分层。

### 容器独立
模块应该独立于运行时容器。

### 独立部署
模块应该是独立的可部署单元。

##3 可用性模式
依赖性模式和可用性模式之间的权衡。
### 发布接口
模块发布的接口应该众所周知。

### 外部配置
模块应该可以在外部进行配置。

### 默认实现
为模块提供一个默认实现

### Module Facade
为具有底层实现的细粒度模式创建一个Facade，使其成为更细粒度模块的入口。

##4 扩展性模式
扩展性模式关注模块的可扩展性。

### 抽象化模块
依赖于模块的抽象元素，依赖于抽象而不是具体。
### 实现工厂
使用工厂创建模块的实现类。
工厂类不能位于要创建的类的模块中，也不能位于类实例要注入的模块中。应该放在独立模块中。----依赖注入框架
### 分离抽象
将抽象和实现放在各自独立的模块中。

##5 通用模式
### 就近异常
### 等级化构建
### 测试模块

**书后面的内容是介绍OSGI了，但是查阅了一些资料，好像在实际应用中不那么好用，包括淘宝的林昊，也承认用OSGI构建系统是过度设计了，过于复杂。
所以后面的内容没再进行细看。
总的来说通过这本书收获了一些概念性的东西和纲领性的东西。翻译的不太通畅。

把《大规模c++程序设计》列入书单。
**








